#![cfg_attr(feature = "axstd", no_std)]
#![cfg_attr(feature = "axstd", no_main)]

#[macro_use]
#[cfg(feature = "axstd")]
extern crate axstd as std;

use axstd::boxed::Box;
use std::io::Write;
use std::os::arceos::api::display::{
    self, ax_framebuffer_flush, ax_framebuffer_info, AxDisplayInfo,
};
use std::os::arceos::modules::axdriver;

use core::mem::MaybeUninit;
use core::time::Duration;
use cstr_core::CString;
use lvgl::NativeObject;
use lvgl::{style::Style, widgets::Label, Align, Color, Display, DrawBuffer, Part, Widget};

// --- Hardcoded Config ---
const HOR_RES: u32 = 1280;
const VER_RES: u32 = 800;
type LvColor = lvgl::Color;

// LVGL 推荐的绘制缓冲区大小: 屏幕的1/10
// 屏幕: 1280 × 800 = 1,024,000 像素  
// 颜色深度: 16位 = 2字节/像素
// 1/10屏幕缓冲区: (1280 × 800 × 2) / 10 = 204,800 字节
// DrawBuffer<N>中N是LvColor的数量，每个LvColor = 2字节
// 所以需要: 204,800 ÷ 2 = 102,400 个LvColor
const DRAW_BUFFER_SIZE: usize = 102400;  // 102,400个LvColor = 200KB

// --- Static Buffers ---
// 用于存储真实物理显存的引用
static mut REAL_FRAMEBUFFER: Option<&'static mut [LvColor]> = None;
// 静态存储 framebuffer 信息
static mut FB_INFO: Option<AxDisplayInfo> = None;

/// ffs (find first set) 是 LVGL 的一个依赖项，用于查找整数中第一个为 1 的位。
#[no_mangle]
pub extern "C" fn ffs(i: i32) -> i32 {
    if i == 0 {
        0
    } else {
        (i as u32).trailing_zeros() as i32 + 1
    }
}

#[no_mangle]
pub extern "C" fn main() -> ! {
    // 简化版本 - 但现在初始化FB_INFO用于flush callback
    let fb_info = ax_framebuffer_info();
    
    // 存储framebuffer信息到静态变量
    unsafe {
        FB_INFO = Some(fb_info);
    }
    
    println!("Before lvgl::init()");
    std::io::stdout().flush().unwrap();

    // 注册 LVGL 日志回调
    unsafe {
        extern "C" fn log_cb(buf: *const u8) {
            if !buf.is_null() {
                unsafe {
                    let c_str = core::ffi::CStr::from_ptr(buf as *const core::ffi::c_char);
                    if let Ok(str_slice) = c_str.to_str() {
                        println!("LVGL: {}", str_slice);
                    }
                }
            }
        }
        lvgl_sys::lv_log_register_print_cb(Some(log_cb));
    }

    lvgl::init();
    println!("After lvgl::init()");
    std::io::stdout().flush().unwrap();

    println!("Creating draw buffer...");
    let buffer = Box::new(DrawBuffer::<DRAW_BUFFER_SIZE>::default());
    println!("Draw buffer created, size: {} bytes ({}KB) - 1/10 screen size", DRAW_BUFFER_SIZE * core::mem::size_of::<LvColor>(), (DRAW_BUFFER_SIZE * core::mem::size_of::<LvColor>()) / 1024);

    println!("LVGL memory management completed");
    std::io::stdout().flush().unwrap();

    // Check LVGL memory status before display registration
    unsafe {
        let mut mem_info = core::mem::MaybeUninit::<lvgl_sys::lv_mem_monitor_t>::uninit();
        lvgl_sys::lv_mem_monitor(mem_info.as_mut_ptr());
        let mem_info = mem_info.assume_init();
        println!("LVGL Memory Status: used={} bytes, free={} bytes, total={} bytes", 
                 mem_info.used_cnt, mem_info.free_cnt, mem_info.total_size);
        println!("Memory usage: {:.1}%", (mem_info.used_cnt as f32 / mem_info.total_size as f32) * 100.0);
        
        // 尝试直接分配一小块内存测试LVGL内存分配器
        println!("Testing LVGL memory allocator...");
        let test_ptr = lvgl_sys::lv_mem_alloc(100);
        if test_ptr.is_null() {
            println!("ERROR: LVGL memory allocation failed!");
        } else {
            println!("LVGL memory allocation test passed");
            lvgl_sys::lv_mem_free(test_ptr);
        }
    }

    // 测试: 尝试创建一个最小的 display
    println!("Testing basic LVGL display creation...");
    std::io::stdout().flush().unwrap();

    // 3. 尝试直接使用LVGL C API进行显示注册，绕过Rust wrapper
    println!("Before Display::register");
    std::io::stdout().flush().unwrap(); // 强制刷新输出
    
    // 直接使用C API而不是Rust wrapper
    unsafe {
        println!("Creating display driver structure...");
        std::io::stdout().flush().unwrap();
        
        // 首先需要初始化draw buffer
        let mut draw_buf = core::mem::MaybeUninit::<lvgl_sys::lv_disp_draw_buf_t>::uninit();
        // 创建一个简单的静态缓冲区来获取指针
        static mut DRAW_BUFFER_STORAGE: [core::mem::MaybeUninit<lvgl_sys::lv_color_t>; DRAW_BUFFER_SIZE] = [core::mem::MaybeUninit::uninit(); DRAW_BUFFER_SIZE];
        let buf_ptr = DRAW_BUFFER_STORAGE.as_mut_ptr() as *mut lvgl_sys::lv_color_t;
        
        println!("Initializing draw buffer...");
        lvgl_sys::lv_disp_draw_buf_init(
            draw_buf.as_mut_ptr(),
            buf_ptr,
            core::ptr::null_mut(), // 没有第二个缓冲区
            DRAW_BUFFER_SIZE as u32,
        );
        let draw_buf = draw_buf.assume_init();
        
        let mut disp_drv = core::mem::MaybeUninit::<lvgl_sys::lv_disp_drv_t>::uninit();
        println!("Initializing display driver...");
        std::io::stdout().flush().unwrap();
        
        lvgl_sys::lv_disp_drv_init(disp_drv.as_mut_ptr());
        println!("Display driver initialized");
        std::io::stdout().flush().unwrap();
        
        let mut disp_drv = disp_drv.assume_init();
        
        // 设置基本参数
        disp_drv.hor_res = HOR_RES as i16;
        disp_drv.ver_res = VER_RES as i16;
        
        // 设置draw buffer
        disp_drv.draw_buf = &draw_buf as *const _ as *mut lvgl_sys::lv_disp_draw_buf_t;
        
        // 设置flush回调函数
        extern "C" fn flush_cb(
            disp_drv: *mut lvgl_sys::lv_disp_drv_t,
            area: *const lvgl_sys::lv_area_t,
            color_p: *mut lvgl_sys::lv_color_t,
        ) {
            unsafe {
                // 获取区域坐标
                let x1 = (*area).x1 as u32;
                let y1 = (*area).y1 as u32;
                let x2 = (*area).x2 as u32;
                let y2 = (*area).y2 as u32;
                
                // 获取framebuffer信息
                if let Some(fb_info) = &FB_INFO {
                    let fb_ptr = fb_info.fb_base_vaddr as *mut u16; // framebuffer是16位RGB565格式
                    let width = HOR_RES;
                    
                    // 复制LVGL渲染的数据到framebuffer
                    for y in y1..=y2 {
                        for x in x1..=x2 {
                            let src_offset = (y - y1) * (x2 - x1 + 1) + (x - x1);
                            let dst_offset = y * width + x;
                            
                            let src_ptr = color_p.add(src_offset as usize);
                            let dst_ptr = fb_ptr.add(dst_offset as usize);
                            
                            // LVGL的颜色格式是16位，直接复制
                            let color_val = (*src_ptr).full; // 获取16位颜色值
                            *dst_ptr = color_val;
                        }
                    }
                }
                
                // 调用系统的framebuffer flush
                ax_framebuffer_flush();
                // 通知LVGL刷新完成
                lvgl_sys::lv_disp_flush_ready(disp_drv);
            }
        }
        
        disp_drv.flush_cb = Some(flush_cb);
        
        println!("About to call lv_disp_drv_register...");
        std::io::stdout().flush().unwrap();
        
        // 这里是问题的关键点
        let disp = lvgl_sys::lv_disp_drv_register(&mut disp_drv as *mut _);
        
        println!("lv_disp_drv_register completed!");
        if disp.is_null() {
            println!("ERROR: Display registration returned NULL");
            panic!("Display registration failed");
        } else {
            println!("SUCCESS: Display registered successfully");
        }
        
        // 现在创建UI元素
        println!("Creating UI elements...");
        
        // 获取当前活动屏幕
        let scr = lvgl_sys::lv_disp_get_scr_act(disp);
        if scr.is_null() {
            println!("ERROR: Failed to get active screen");
            panic!("Failed to get screen");
        }
        
        // 设置屏幕背景色为白色 (RGB565格式: 0xFFFF)
        let white_color = lvgl_sys::lv_color_t { full: 0xFFFF };
        lvgl_sys::lv_obj_set_style_bg_color(scr, white_color, 0);
        
        // 创建标签
        let label = lvgl_sys::lv_label_create(scr);
        if label.is_null() {
            println!("ERROR: Failed to create label");
            panic!("Failed to create label");
        }
        
        let text = b"Hello LVGL!\0".as_ptr() as *const u8;
        lvgl_sys::lv_label_set_text(label, text);
        
        // 手动设置标签位置到屏幕中心
        let screen_width = HOR_RES as i16;
        let screen_height = VER_RES as i16;
        lvgl_sys::lv_obj_set_pos(label, (screen_width / 2) - 50, (screen_height / 2) - 10);
        
        // 设置标签文字颜色为黑色 (RGB565格式: 0x0000)
        let black_color = lvgl_sys::lv_color_t { full: 0x0000 };
        lvgl_sys::lv_obj_set_style_text_color(label, black_color, 0);
        
        println!("UI elements created, forcing refresh...");
        
        // 强制刷新显示
        lvgl_sys::lv_obj_invalidate(scr);
        lvgl_sys::lv_refr_now(disp);
        
        println!("First refresh completed!");
    }
    
    println!("Starting main loop...");
    
    // 主循环
    let mut counter = 0;
    loop {
        unsafe {
            lvgl::tick_inc(Duration::from_millis(5));
            lvgl::task_handler();
        }
        
        counter += 1;
        if counter % 20 == 0 {
            println!("Main loop iteration {}", counter);
        }
        
        std::thread::sleep(Duration::from_millis(5));
    }
}
